'''
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: ASLUAV.xml,pixhawk.xml

Note: this file has been auto-generated. DO NOT EDIT
'''

import struct, array, mavutil, time

WIRE_PROTOCOL_VERSION = "0.9"

class MAVLink_header(object):
    '''MAVLink message header'''
    def __init__(self, msgId, mlen=0, seq=0, srcSystem=0, srcComponent=0):
        self.mlen = mlen
        self.seq = seq
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.msgId = msgId

    def pack(self):
        return struct.pack('BBBBBB', 85, self.mlen, self.seq,
                          self.srcSystem, self.srcComponent, self.msgId)

class MAVLink_message(object):
    '''base MAVLink message class'''
    def __init__(self, msgId, name):
        self._header     = MAVLink_header(msgId)
        self._payload    = None
        self._msgbuf     = None
        self._crc        = None
        self._fieldnames = []
        self._type       = name

    def get_msgbuf(self):
        return self._msgbuf

    def get_header(self):
        return self._header

    def get_payload(self):
        return self._payload

    def get_crc(self):
        return self._crc

    def get_fieldnames(self):
        return self._fieldnames

    def get_type(self):
        return self._type

    def get_msgId(self):
        return self._header.msgId

    def get_srcSystem(self):
        return self._header.srcSystem

    def get_srcComponent(self):
        return self._header.srcComponent

    def get_seq(self):
        return self._header.seq

    def __str__(self):
        ret = '%s {' % self._type
        for a in self._fieldnames:
            v = getattr(self, a)
            ret += '%s : %s, ' % (a, v)
        ret = ret[0:-2] + '}'
        return ret            

    def pack(self, mav, crc_extra, payload):
        self._payload = payload
        self._header  = MAVLink_header(self._header.msgId, len(payload), mav.seq,
                                       mav.srcSystem, mav.srcComponent)
        self._msgbuf = self._header.pack() + payload
        crc = mavutil.x25crc(self._msgbuf[1:])
        if False: # using CRC extra
            crc.accumulate(chr(crc_extra))
        self._crc = crc.crc
        self._msgbuf += struct.pack('<H', self._crc)
        return self._msgbuf


# enums

# MAV_AUTOPILOT
MAV_AUTOPILOT_GENERIC = 0 # Generic autopilot, full support foMAV_CMD_DO_START_SEARCHr everything
                        # |
MAV_AUTOPILOT_PIXHAWK = 1 # PIXHAWK autopilot, http://pixhawk.ethz.ch |
MAV_AUTOPILOT_SLUGS = 2 # SLUGS autopilot, http://slugsuav.soe.ucsc.edu |
MAV_AUTOPILOT_ARDUPILOTMEGA = 3 # ArduPilotMega / ArduCopter, http://diydrones.com |
MAV_AUTOPILOT_OPENPILOT = 4 # OpenPilot, http://openpilot.org |
MAV_AUTOPILOT_GENERIC_WAYPOINTS_ONLY = 5 # Generic autopilot only supporting simple waypoints |
MAV_AUTOPILOT_GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY = 6 # Generic autopilot supporting waypoints and other simple navigation
                        # commands |
MAV_AUTOPILOT_GENERIC_MISSION_FULL = 7 # 
MAV_AUTOPILOT_INVALID = 8 # No valid autopilot, e.g. a GCS or other MAVLink component |
MAV_AUTOPILOT_PPZ = 9 # PPZ UAV - http://nongnu.org/paparazzi |
MAV_AUTOPILOT_UDB = 10 # UAV Dev Board |
MAV_AUTOPILOT_FP = 11 # FlexiPilot |
MAV_AUTOPILOT_PX4 = 12 # PX4 Autopilot - http://pixhawk.ethz.ch/px4/ |
MAV_AUTOPILOT_SMACCMPILOT = 13 # SMACCMPilot - http://smaccmpilot.org|
MAV_AUTOPILOT_AUTOQUAD = 14 # AutoQuad -- http://autoquad.org
MAV_AUTOPILOT_ASLUAV = 15 # ASLUAV - ETH Zurich Autonomous Systems Lab UAVs, asl.ethz.ch
MAV_AUTOPILOT_ENUM_END = 16 # 

# DATA_TYPES
DATA_TYPE_JPEG_IMAGE = 1 # 
DATA_TYPE_RAW_IMAGE = 2 # 
DATA_TYPE_KINECT = 3 # 
DATA_TYPES_ENUM_END = 4 # 

# MAV_CMD
MAV_CMD_DO_START_SEARCH = 10001 # Starts a search
MAV_CMD_DO_FINISH_SEARCH = 10002 # Starts a search
MAV_CMD_NAV_SWEEP = 10003 # Starts a search
MAV_CMD_ENUM_END = 10004 # 

# message IDs
MAVLINK_MSG_ID_BAD_DATA = -1
MAVLINK_MSG_ID_XBEE_HARDRESET = 201
MAVLINK_MSG_ID_CUSTOM_SENSOR_DATA = 202
MAVLINK_MSG_ID_SET_CAM_SHUTTER = 151
MAVLINK_MSG_ID_IMAGE_TRIGGERED = 152
MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL = 153
MAVLINK_MSG_ID_IMAGE_AVAILABLE = 154
MAVLINK_MSG_ID_SET_POSITION_CONTROL_OFFSET = 160
MAVLINK_MSG_ID_POSITION_CONTROL_SETPOINT = 170
MAVLINK_MSG_ID_MARKER = 171
MAVLINK_MSG_ID_RAW_AUX = 172
MAVLINK_MSG_ID_WATCHDOG_HEARTBEAT = 180
MAVLINK_MSG_ID_WATCHDOG_PROCESS_INFO = 181
MAVLINK_MSG_ID_WATCHDOG_PROCESS_STATUS = 182
MAVLINK_MSG_ID_WATCHDOG_COMMAND = 183
MAVLINK_MSG_ID_PATTERN_DETECTED = 190
MAVLINK_MSG_ID_POINT_OF_INTEREST = 191
MAVLINK_MSG_ID_POINT_OF_INTEREST_CONNECTION = 192
MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE = 193
MAVLINK_MSG_ID_ENCAPSULATED_DATA = 194
MAVLINK_MSG_ID_BRIEF_FEATURE = 195
MAVLINK_MSG_ID_ATTITUDE_CONTROL = 200

class MAVLink_xbee_hardreset_message(MAVLink_message):
        '''

        '''
        def __init__(self, test):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_XBEE_HARDRESET, 'XBEE_HARDRESET')
                self._fieldnames = ['test']
                self.test = test

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 52, struct.pack('>B', self.test))

class MAVLink_custom_sensor_data_message(MAVLink_message):
        '''

        '''
        def __init__(self, dbaro_pres_pa, dbaro_velo_ms, amb_temp_celsius, adc121_vspb_volt, adc121_cspb_amp, adc121_cs1_amp, adc121_cs2_amp, mppt1_volt, mppt1_amp, mppt1_pwm, mppt1_status, mppt2_volt, mppt2_amp, mppt2_pwm, mppt2_status, mppt3_volt, mppt3_amp, mppt3_pwm, mppt3_status):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_CUSTOM_SENSOR_DATA, 'CUSTOM_SENSOR_DATA')
                self._fieldnames = ['dbaro_pres_pa', 'dbaro_velo_ms', 'amb_temp_celsius', 'adc121_vspb_volt', 'adc121_cspb_amp', 'adc121_cs1_amp', 'adc121_cs2_amp', 'mppt1_volt', 'mppt1_amp', 'mppt1_pwm', 'mppt1_status', 'mppt2_volt', 'mppt2_amp', 'mppt2_pwm', 'mppt2_status', 'mppt3_volt', 'mppt3_amp', 'mppt3_pwm', 'mppt3_status']
                self.dbaro_pres_pa = dbaro_pres_pa
                self.dbaro_velo_ms = dbaro_velo_ms
                self.amb_temp_celsius = amb_temp_celsius
                self.adc121_vspb_volt = adc121_vspb_volt
                self.adc121_cspb_amp = adc121_cspb_amp
                self.adc121_cs1_amp = adc121_cs1_amp
                self.adc121_cs2_amp = adc121_cs2_amp
                self.mppt1_volt = mppt1_volt
                self.mppt1_amp = mppt1_amp
                self.mppt1_pwm = mppt1_pwm
                self.mppt1_status = mppt1_status
                self.mppt2_volt = mppt2_volt
                self.mppt2_amp = mppt2_amp
                self.mppt2_pwm = mppt2_pwm
                self.mppt2_status = mppt2_status
                self.mppt3_volt = mppt3_volt
                self.mppt3_amp = mppt3_amp
                self.mppt3_pwm = mppt3_pwm
                self.mppt3_status = mppt3_status

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 242, struct.pack('>fffffffffffffffffff', self.dbaro_pres_pa, self.dbaro_velo_ms, self.amb_temp_celsius, self.adc121_vspb_volt, self.adc121_cspb_amp, self.adc121_cs1_amp, self.adc121_cs2_amp, self.mppt1_volt, self.mppt1_amp, self.mppt1_pwm, self.mppt1_status, self.mppt2_volt, self.mppt2_amp, self.mppt2_pwm, self.mppt2_status, self.mppt3_volt, self.mppt3_amp, self.mppt3_pwm, self.mppt3_status))

class MAVLink_set_cam_shutter_message(MAVLink_message):
        '''

        '''
        def __init__(self, cam_no, cam_mode, trigger_pin, interval, exposure, gain):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_SET_CAM_SHUTTER, 'SET_CAM_SHUTTER')
                self._fieldnames = ['cam_no', 'cam_mode', 'trigger_pin', 'interval', 'exposure', 'gain']
                self.cam_no = cam_no
                self.cam_mode = cam_mode
                self.trigger_pin = trigger_pin
                self.interval = interval
                self.exposure = exposure
                self.gain = gain

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 204, struct.pack('>BBBHHf', self.cam_no, self.cam_mode, self.trigger_pin, self.interval, self.exposure, self.gain))

class MAVLink_image_triggered_message(MAVLink_message):
        '''

        '''
        def __init__(self, timestamp, seq, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_IMAGE_TRIGGERED, 'IMAGE_TRIGGERED')
                self._fieldnames = ['timestamp', 'seq', 'roll', 'pitch', 'yaw', 'local_z', 'lat', 'lon', 'alt', 'ground_x', 'ground_y', 'ground_z']
                self.timestamp = timestamp
                self.seq = seq
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.local_z = local_z
                self.lat = lat
                self.lon = lon
                self.alt = alt
                self.ground_x = ground_x
                self.ground_y = ground_y
                self.ground_z = ground_z

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 86, struct.pack('>QIffffffffff', self.timestamp, self.seq, self.roll, self.pitch, self.yaw, self.local_z, self.lat, self.lon, self.alt, self.ground_x, self.ground_y, self.ground_z))

class MAVLink_image_trigger_control_message(MAVLink_message):
        '''

        '''
        def __init__(self, enable):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL, 'IMAGE_TRIGGER_CONTROL')
                self._fieldnames = ['enable']
                self.enable = enable

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 95, struct.pack('>B', self.enable))

class MAVLink_image_available_message(MAVLink_message):
        '''

        '''
        def __init__(self, cam_id, cam_no, timestamp, valid_until, img_seq, img_buf_index, width, height, depth, channels, key, exposure, gain, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_IMAGE_AVAILABLE, 'IMAGE_AVAILABLE')
                self._fieldnames = ['cam_id', 'cam_no', 'timestamp', 'valid_until', 'img_seq', 'img_buf_index', 'width', 'height', 'depth', 'channels', 'key', 'exposure', 'gain', 'roll', 'pitch', 'yaw', 'local_z', 'lat', 'lon', 'alt', 'ground_x', 'ground_y', 'ground_z']
                self.cam_id = cam_id
                self.cam_no = cam_no
                self.timestamp = timestamp
                self.valid_until = valid_until
                self.img_seq = img_seq
                self.img_buf_index = img_buf_index
                self.width = width
                self.height = height
                self.depth = depth
                self.channels = channels
                self.key = key
                self.exposure = exposure
                self.gain = gain
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.local_z = local_z
                self.lat = lat
                self.lon = lon
                self.alt = alt
                self.ground_x = ground_x
                self.ground_y = ground_y
                self.ground_z = ground_z

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 49, struct.pack('>QBQQIIHHHBIIfffffffffff', self.cam_id, self.cam_no, self.timestamp, self.valid_until, self.img_seq, self.img_buf_index, self.width, self.height, self.depth, self.channels, self.key, self.exposure, self.gain, self.roll, self.pitch, self.yaw, self.local_z, self.lat, self.lon, self.alt, self.ground_x, self.ground_y, self.ground_z))

class MAVLink_set_position_control_offset_message(MAVLink_message):
        '''
        Message sent to the MAV to set a new offset from the currently
        controlled position
        '''
        def __init__(self, target_system, target_component, x, y, z, yaw):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_SET_POSITION_CONTROL_OFFSET, 'SET_POSITION_CONTROL_OFFSET')
                self._fieldnames = ['target_system', 'target_component', 'x', 'y', 'z', 'yaw']
                self.target_system = target_system
                self.target_component = target_component
                self.x = x
                self.y = y
                self.z = z
                self.yaw = yaw

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 145, struct.pack('>BBffff', self.target_system, self.target_component, self.x, self.y, self.z, self.yaw))

class MAVLink_position_control_setpoint_message(MAVLink_message):
        '''

        '''
        def __init__(self, id, x, y, z, yaw):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_POSITION_CONTROL_SETPOINT, 'POSITION_CONTROL_SETPOINT')
                self._fieldnames = ['id', 'x', 'y', 'z', 'yaw']
                self.id = id
                self.x = x
                self.y = y
                self.z = z
                self.yaw = yaw

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 220, struct.pack('>Hffff', self.id, self.x, self.y, self.z, self.yaw))

class MAVLink_marker_message(MAVLink_message):
        '''

        '''
        def __init__(self, id, x, y, z, roll, pitch, yaw):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_MARKER, 'MARKER')
                self._fieldnames = ['id', 'x', 'y', 'z', 'roll', 'pitch', 'yaw']
                self.id = id
                self.x = x
                self.y = y
                self.z = z
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 136, struct.pack('>Hffffff', self.id, self.x, self.y, self.z, self.roll, self.pitch, self.yaw))

class MAVLink_raw_aux_message(MAVLink_message):
        '''

        '''
        def __init__(self, adc1, adc2, adc3, adc4, vbat, temp, baro):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_RAW_AUX, 'RAW_AUX')
                self._fieldnames = ['adc1', 'adc2', 'adc3', 'adc4', 'vbat', 'temp', 'baro']
                self.adc1 = adc1
                self.adc2 = adc2
                self.adc3 = adc3
                self.adc4 = adc4
                self.vbat = vbat
                self.temp = temp
                self.baro = baro

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 140, struct.pack('>HHHHHhi', self.adc1, self.adc2, self.adc3, self.adc4, self.vbat, self.temp, self.baro))

class MAVLink_watchdog_heartbeat_message(MAVLink_message):
        '''

        '''
        def __init__(self, watchdog_id, process_count):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_WATCHDOG_HEARTBEAT, 'WATCHDOG_HEARTBEAT')
                self._fieldnames = ['watchdog_id', 'process_count']
                self.watchdog_id = watchdog_id
                self.process_count = process_count

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 153, struct.pack('>HH', self.watchdog_id, self.process_count))

class MAVLink_watchdog_process_info_message(MAVLink_message):
        '''

        '''
        def __init__(self, watchdog_id, process_id, name, arguments, timeout):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_WATCHDOG_PROCESS_INFO, 'WATCHDOG_PROCESS_INFO')
                self._fieldnames = ['watchdog_id', 'process_id', 'name', 'arguments', 'timeout']
                self.watchdog_id = watchdog_id
                self.process_id = process_id
                self.name = name
                self.arguments = arguments
                self.timeout = timeout

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 216, struct.pack('>HH100s147si', self.watchdog_id, self.process_id, self.name, self.arguments, self.timeout))

class MAVLink_watchdog_process_status_message(MAVLink_message):
        '''

        '''
        def __init__(self, watchdog_id, process_id, state, muted, pid, crashes):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_WATCHDOG_PROCESS_STATUS, 'WATCHDOG_PROCESS_STATUS')
                self._fieldnames = ['watchdog_id', 'process_id', 'state', 'muted', 'pid', 'crashes']
                self.watchdog_id = watchdog_id
                self.process_id = process_id
                self.state = state
                self.muted = muted
                self.pid = pid
                self.crashes = crashes

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 92, struct.pack('>HHBBiH', self.watchdog_id, self.process_id, self.state, self.muted, self.pid, self.crashes))

class MAVLink_watchdog_command_message(MAVLink_message):
        '''

        '''
        def __init__(self, target_system_id, watchdog_id, process_id, command_id):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_WATCHDOG_COMMAND, 'WATCHDOG_COMMAND')
                self._fieldnames = ['target_system_id', 'watchdog_id', 'process_id', 'command_id']
                self.target_system_id = target_system_id
                self.watchdog_id = watchdog_id
                self.process_id = process_id
                self.command_id = command_id

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 188, struct.pack('>BHHB', self.target_system_id, self.watchdog_id, self.process_id, self.command_id))

class MAVLink_pattern_detected_message(MAVLink_message):
        '''

        '''
        def __init__(self, type, confidence, file, detected):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_PATTERN_DETECTED, 'PATTERN_DETECTED')
                self._fieldnames = ['type', 'confidence', 'file', 'detected']
                self.type = type
                self.confidence = confidence
                self.file = file
                self.detected = detected

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 106, struct.pack('>Bf100sB', self.type, self.confidence, self.file, self.detected))

class MAVLink_point_of_interest_message(MAVLink_message):
        '''
        Notifies the operator about a point of interest (POI). This
        can be anything detected by the                 system. This
        generic message is intented to help interfacing to generic
        visualizations and to display                 the POI on a
        map.
        '''
        def __init__(self, type, color, coordinate_system, timeout, x, y, z, name):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_POINT_OF_INTEREST, 'POINT_OF_INTEREST')
                self._fieldnames = ['type', 'color', 'coordinate_system', 'timeout', 'x', 'y', 'z', 'name']
                self.type = type
                self.color = color
                self.coordinate_system = coordinate_system
                self.timeout = timeout
                self.x = x
                self.y = y
                self.z = z
                self.name = name

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 154, struct.pack('>BBBHfff26s', self.type, self.color, self.coordinate_system, self.timeout, self.x, self.y, self.z, self.name))

class MAVLink_point_of_interest_connection_message(MAVLink_message):
        '''
        Notifies the operator about the connection of two point of
        interests (POI). This can be anything detected by the
        system. This generic message is intented to help interfacing
        to generic visualizations and to display                 the
        POI on a map.
        '''
        def __init__(self, type, color, coordinate_system, timeout, xp1, yp1, zp1, xp2, yp2, zp2, name):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_POINT_OF_INTEREST_CONNECTION, 'POINT_OF_INTEREST_CONNECTION')
                self._fieldnames = ['type', 'color', 'coordinate_system', 'timeout', 'xp1', 'yp1', 'zp1', 'xp2', 'yp2', 'zp2', 'name']
                self.type = type
                self.color = color
                self.coordinate_system = coordinate_system
                self.timeout = timeout
                self.xp1 = xp1
                self.yp1 = yp1
                self.zp1 = zp1
                self.xp2 = xp2
                self.yp2 = yp2
                self.zp2 = zp2
                self.name = name

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 83, struct.pack('>BBBHffffff26s', self.type, self.color, self.coordinate_system, self.timeout, self.xp1, self.yp1, self.zp1, self.xp2, self.yp2, self.zp2, self.name))

class MAVLink_data_transmission_handshake_message(MAVLink_message):
        '''

        '''
        def __init__(self, type, size, width, height, packets, payload, jpg_quality):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE, 'DATA_TRANSMISSION_HANDSHAKE')
                self._fieldnames = ['type', 'size', 'width', 'height', 'packets', 'payload', 'jpg_quality']
                self.type = type
                self.size = size
                self.width = width
                self.height = height
                self.packets = packets
                self.payload = payload
                self.jpg_quality = jpg_quality

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 135, struct.pack('>BIHHBBB', self.type, self.size, self.width, self.height, self.packets, self.payload, self.jpg_quality))

class MAVLink_encapsulated_data_message(MAVLink_message):
        '''

        '''
        def __init__(self, seqnr, data):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_ENCAPSULATED_DATA, 'ENCAPSULATED_DATA')
                self._fieldnames = ['seqnr', 'data']
                self.seqnr = seqnr
                self.data = data

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 172, struct.pack('>H253s', self.seqnr, self.data))

class MAVLink_brief_feature_message(MAVLink_message):
        '''

        '''
        def __init__(self, x, y, z, orientation_assignment, size, orientation, descriptor, response):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_BRIEF_FEATURE, 'BRIEF_FEATURE')
                self._fieldnames = ['x', 'y', 'z', 'orientation_assignment', 'size', 'orientation', 'descriptor', 'response']
                self.x = x
                self.y = y
                self.z = z
                self.orientation_assignment = orientation_assignment
                self.size = size
                self.orientation = orientation
                self.descriptor = descriptor
                self.response = response

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 254, struct.pack('>fffBHH32sf', self.x, self.y, self.z, self.orientation_assignment, self.size, self.orientation, self.descriptor, self.response))

class MAVLink_attitude_control_message(MAVLink_message):
        '''

        '''
        def __init__(self, target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_ATTITUDE_CONTROL, 'ATTITUDE_CONTROL')
                self._fieldnames = ['target', 'roll', 'pitch', 'yaw', 'thrust', 'roll_manual', 'pitch_manual', 'yaw_manual', 'thrust_manual']
                self.target = target
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.thrust = thrust
                self.roll_manual = roll_manual
                self.pitch_manual = pitch_manual
                self.yaw_manual = yaw_manual
                self.thrust_manual = thrust_manual

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 84, struct.pack('>BffffBBBB', self.target, self.roll, self.pitch, self.yaw, self.thrust, self.roll_manual, self.pitch_manual, self.yaw_manual, self.thrust_manual))


mavlink_map = {
        MAVLINK_MSG_ID_XBEE_HARDRESET : ( '>B', MAVLink_xbee_hardreset_message, [0], 52 ),
        MAVLINK_MSG_ID_CUSTOM_SENSOR_DATA : ( '>fffffffffffffffffff', MAVLink_custom_sensor_data_message, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18], 242 ),
        MAVLINK_MSG_ID_SET_CAM_SHUTTER : ( '>BBBHHf', MAVLink_set_cam_shutter_message, [0, 1, 2, 3, 4, 5], 204 ),
        MAVLINK_MSG_ID_IMAGE_TRIGGERED : ( '>QIffffffffff', MAVLink_image_triggered_message, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 86 ),
        MAVLINK_MSG_ID_IMAGE_TRIGGER_CONTROL : ( '>B', MAVLink_image_trigger_control_message, [0], 95 ),
        MAVLINK_MSG_ID_IMAGE_AVAILABLE : ( '>QBQQIIHHHBIIfffffffffff', MAVLink_image_available_message, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22], 49 ),
        MAVLINK_MSG_ID_SET_POSITION_CONTROL_OFFSET : ( '>BBffff', MAVLink_set_position_control_offset_message, [0, 1, 2, 3, 4, 5], 145 ),
        MAVLINK_MSG_ID_POSITION_CONTROL_SETPOINT : ( '>Hffff', MAVLink_position_control_setpoint_message, [0, 1, 2, 3, 4], 220 ),
        MAVLINK_MSG_ID_MARKER : ( '>Hffffff', MAVLink_marker_message, [0, 1, 2, 3, 4, 5, 6], 136 ),
        MAVLINK_MSG_ID_RAW_AUX : ( '>HHHHHhi', MAVLink_raw_aux_message, [0, 1, 2, 3, 4, 5, 6], 140 ),
        MAVLINK_MSG_ID_WATCHDOG_HEARTBEAT : ( '>HH', MAVLink_watchdog_heartbeat_message, [0, 1], 153 ),
        MAVLINK_MSG_ID_WATCHDOG_PROCESS_INFO : ( '>HH100s147si', MAVLink_watchdog_process_info_message, [0, 1, 2, 3, 4], 216 ),
        MAVLINK_MSG_ID_WATCHDOG_PROCESS_STATUS : ( '>HHBBiH', MAVLink_watchdog_process_status_message, [0, 1, 2, 3, 4, 5], 92 ),
        MAVLINK_MSG_ID_WATCHDOG_COMMAND : ( '>BHHB', MAVLink_watchdog_command_message, [0, 1, 2, 3], 188 ),
        MAVLINK_MSG_ID_PATTERN_DETECTED : ( '>Bf100sB', MAVLink_pattern_detected_message, [0, 1, 2, 3], 106 ),
        MAVLINK_MSG_ID_POINT_OF_INTEREST : ( '>BBBHfff26s', MAVLink_point_of_interest_message, [0, 1, 2, 3, 4, 5, 6, 7], 154 ),
        MAVLINK_MSG_ID_POINT_OF_INTEREST_CONNECTION : ( '>BBBHffffff26s', MAVLink_point_of_interest_connection_message, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 83 ),
        MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE : ( '>BIHHBBB', MAVLink_data_transmission_handshake_message, [0, 1, 2, 3, 4, 5, 6], 135 ),
        MAVLINK_MSG_ID_ENCAPSULATED_DATA : ( '>H253s', MAVLink_encapsulated_data_message, [0, 1], 172 ),
        MAVLINK_MSG_ID_BRIEF_FEATURE : ( '>fffBHH32sf', MAVLink_brief_feature_message, [0, 1, 2, 3, 4, 5, 6, 7], 254 ),
        MAVLINK_MSG_ID_ATTITUDE_CONTROL : ( '>BffffBBBB', MAVLink_attitude_control_message, [0, 1, 2, 3, 4, 5, 6, 7, 8], 84 ),
}

class MAVError(Exception):
        '''MAVLink error class'''
        def __init__(self, msg):
            Exception.__init__(self, msg)
            self.message = msg

class MAVString(str):
        '''NUL terminated string'''
        def __init__(self, s):
                str.__init__(self)
        def __str__(self):
            i = self.find(chr(0))
            if i == -1:
                return self[:]
            return self[0:i]

class MAVLink_bad_data(MAVLink_message):
        '''
        a piece of bad data in a mavlink stream
        '''
        def __init__(self, data, reason):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_BAD_DATA, 'BAD_DATA')
                self._fieldnames = ['data', 'reason']
                self.data = data
                self.reason = reason
                self._msgbuf = data
            
class MAVLink(object):
        '''MAVLink protocol handling class'''
        def __init__(self, file, srcSystem=0, srcComponent=0):
                self.seq = 0
                self.file = file
                self.srcSystem = srcSystem
                self.srcComponent = srcComponent
                self.callback = None
                self.callback_args = None
                self.callback_kwargs = None
                self.buf = array.array('B')
                self.expected_length = 6
                self.have_prefix_error = False
                self.robust_parsing = False
                self.protocol_marker = 85
                self.little_endian = False
                self.crc_extra = False
                self.sort_fields = False
                self.total_packets_sent = 0
                self.total_bytes_sent = 0
                self.total_packets_received = 0
                self.total_bytes_received = 0
                self.total_receive_errors = 0
                self.startup_time = time.time()

        def set_callback(self, callback, *args, **kwargs):
            self.callback = callback
            self.callback_args = args
            self.callback_kwargs = kwargs
            
        def send(self, mavmsg):
                '''send a MAVLink message'''
                buf = mavmsg.pack(self)
                self.file.write(buf)
                self.seq = (self.seq + 1) % 255
                self.total_packets_sent += 1
                self.total_bytes_sent += len(buf)

        def bytes_needed(self):
            '''return number of bytes needed for next parsing stage'''
            ret = self.expected_length - len(self.buf)
            if ret <= 0:
                return 1
            return ret

        def parse_char(self, c):
            '''input some data bytes, possibly returning a new message'''
            if isinstance(c, str):
                self.buf.fromstring(c)
            else:
                self.buf.extend(c)
            self.total_bytes_received += len(c)
            if len(self.buf) >= 1 and self.buf[0] != 85:
                magic = self.buf[0]
                self.buf = self.buf[1:]
                if self.robust_parsing:
                    m = MAVLink_bad_data(chr(magic), "Bad prefix")
                    if self.callback:
                        self.callback(m, *self.callback_args, **self.callback_kwargs)
                    self.expected_length = 6
                    self.total_receive_errors += 1
                    return m
                if self.have_prefix_error:
                    return None
                self.have_prefix_error = True
                self.total_receive_errors += 1
                raise MAVError("invalid MAVLink prefix '%s'" % magic) 
            self.have_prefix_error = False
            if len(self.buf) >= 2:
                (magic, self.expected_length) = struct.unpack('BB', self.buf[0:2])
                self.expected_length += 8
            if self.expected_length >= 8 and len(self.buf) >= self.expected_length:
                mbuf = self.buf[0:self.expected_length]
                self.buf = self.buf[self.expected_length:]
                self.expected_length = 6
                if self.robust_parsing:
                    try:
                        m = self.decode(mbuf)
                        self.total_packets_received += 1
                    except MAVError as reason:
                        m = MAVLink_bad_data(mbuf, reason.message)
                        self.total_receive_errors += 1
                else:
                    m = self.decode(mbuf)
                    self.total_packets_received += 1
                if self.callback:
                    self.callback(m, *self.callback_args, **self.callback_kwargs)
                return m
            return None

        def parse_buffer(self, s):
            '''input some data bytes, possibly returning a list of new messages'''
            m = self.parse_char(s)
            if m is None:
                return None
            ret = [m]
            while True:
                m = self.parse_char("")
                if m is None:
                    return ret
                ret.append(m)
            return ret

        def decode(self, msgbuf):
                '''decode a buffer as a MAVLink message'''
                # decode the header
                try:
                    magic, mlen, seq, srcSystem, srcComponent, msgId = struct.unpack('cBBBBB', msgbuf[:6])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink header: %s' % emsg)
                if ord(magic) != 85:
                    raise MAVError("invalid MAVLink prefix '%s'" % magic)
                if mlen != len(msgbuf)-8:
                    raise MAVError('invalid MAVLink message length. Got %u expected %u, msgId=%u' % (len(msgbuf)-8, mlen, msgId))

                if not msgId in mavlink_map:
                    raise MAVError('unknown MAVLink message ID %u' % msgId)

                # decode the payload
                (fmt, type, order_map, crc_extra) = mavlink_map[msgId]

                # decode the checksum
                try:
                    crc, = struct.unpack('<H', msgbuf[-2:])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink CRC: %s' % emsg)
                crc2 = mavutil.x25crc(msgbuf[1:-2])
                if False: # using CRC extra 
                    crc2.accumulate(chr(crc_extra))
                if crc != crc2.crc:
                    raise MAVError('invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x' % (msgId, crc, crc2.crc))

                try:
                    t = struct.unpack(fmt, msgbuf[6:-2])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink payload type=%s fmt=%s payloadLength=%u: %s' % (
                        type, fmt, len(msgbuf[6:-2]), emsg))

                tlist = list(t)
                # handle sorted fields
                if False:
                    t = tlist[:]
                    for i in range(0, len(tlist)):
                        tlist[i] = t[order_map[i]]

                # terminate any strings
                for i in range(0, len(tlist)):
                    if isinstance(tlist[i], str):
                        tlist[i] = MAVString(tlist[i])
                t = tuple(tlist)
                # construct the message object
                try:
                    m = type(*t)
                except Exception as emsg:
                    raise MAVError('Unable to instantiate MAVLink message of type %s : %s' % (type, emsg))
                m._msgbuf = msgbuf
                m._payload = msgbuf[6:-2]
                m._crc = crc
                m._header = MAVLink_header(msgId, mlen, seq, srcSystem, srcComponent)
                return m
        def xbee_hardreset_encode(self, test):
                '''
                

                test                      : test data (uint8_t)

                '''
                msg = MAVLink_xbee_hardreset_message(test)
                msg.pack(self)
                return msg
            
        def xbee_hardreset_send(self, test):
                '''
                

                test                      : test data (uint8_t)

                '''
                return self.send(self.xbee_hardreset_encode(test))
            
        def custom_sensor_data_encode(self, dbaro_pres_pa, dbaro_velo_ms, amb_temp_celsius, adc121_vspb_volt, adc121_cspb_amp, adc121_cs1_amp, adc121_cs2_amp, mppt1_volt, mppt1_amp, mppt1_pwm, mppt1_status, mppt2_volt, mppt2_amp, mppt2_pwm, mppt2_status, mppt3_volt, mppt3_amp, mppt3_pwm, mppt3_status):
                '''
                

                dbaro_pres_pa             : Differential pressure, already temp. comp. (float)
                dbaro_velo_ms             : Velocity calculation from dpressure sensor	in m/sec (float)
                amb_temp_celsius          : Ambient temperature in degrees celsius (float)
                adc121_vspb_volt          : Power board voltage sensor reading in volts (float)
                adc121_cspb_amp           : Power board current sensor reading in amps (float)
                adc121_cs1_amp            : Board current sensor 1 reading in amps (float)
                adc121_cs2_amp            : Board current sensor 2 reading in amps (float)
                mppt1_volt                : MPPT1 voltage (float)
                mppt1_amp                 : MPPT1 current (float)
                mppt1_pwm                 : MPPT1 pwm (float)
                mppt1_status              : MPPT1 status (float)
                mppt2_volt                : MPPT2 voltage (float)
                mppt2_amp                 : MPPT2 current (float)
                mppt2_pwm                 : MPPT2 pwm (float)
                mppt2_status              : MPPT2 status (float)
                mppt3_volt                : MPPT3 voltage (float)
                mppt3_amp                 : MPPT3 current (float)
                mppt3_pwm                 : MPPT3 pwm (float)
                mppt3_status              : MPPT3 status (float)

                '''
                msg = MAVLink_custom_sensor_data_message(dbaro_pres_pa, dbaro_velo_ms, amb_temp_celsius, adc121_vspb_volt, adc121_cspb_amp, adc121_cs1_amp, adc121_cs2_amp, mppt1_volt, mppt1_amp, mppt1_pwm, mppt1_status, mppt2_volt, mppt2_amp, mppt2_pwm, mppt2_status, mppt3_volt, mppt3_amp, mppt3_pwm, mppt3_status)
                msg.pack(self)
                return msg
            
        def custom_sensor_data_send(self, dbaro_pres_pa, dbaro_velo_ms, amb_temp_celsius, adc121_vspb_volt, adc121_cspb_amp, adc121_cs1_amp, adc121_cs2_amp, mppt1_volt, mppt1_amp, mppt1_pwm, mppt1_status, mppt2_volt, mppt2_amp, mppt2_pwm, mppt2_status, mppt3_volt, mppt3_amp, mppt3_pwm, mppt3_status):
                '''
                

                dbaro_pres_pa             : Differential pressure, already temp. comp. (float)
                dbaro_velo_ms             : Velocity calculation from dpressure sensor	in m/sec (float)
                amb_temp_celsius          : Ambient temperature in degrees celsius (float)
                adc121_vspb_volt          : Power board voltage sensor reading in volts (float)
                adc121_cspb_amp           : Power board current sensor reading in amps (float)
                adc121_cs1_amp            : Board current sensor 1 reading in amps (float)
                adc121_cs2_amp            : Board current sensor 2 reading in amps (float)
                mppt1_volt                : MPPT1 voltage (float)
                mppt1_amp                 : MPPT1 current (float)
                mppt1_pwm                 : MPPT1 pwm (float)
                mppt1_status              : MPPT1 status (float)
                mppt2_volt                : MPPT2 voltage (float)
                mppt2_amp                 : MPPT2 current (float)
                mppt2_pwm                 : MPPT2 pwm (float)
                mppt2_status              : MPPT2 status (float)
                mppt3_volt                : MPPT3 voltage (float)
                mppt3_amp                 : MPPT3 current (float)
                mppt3_pwm                 : MPPT3 pwm (float)
                mppt3_status              : MPPT3 status (float)

                '''
                return self.send(self.custom_sensor_data_encode(dbaro_pres_pa, dbaro_velo_ms, amb_temp_celsius, adc121_vspb_volt, adc121_cspb_amp, adc121_cs1_amp, adc121_cs2_amp, mppt1_volt, mppt1_amp, mppt1_pwm, mppt1_status, mppt2_volt, mppt2_amp, mppt2_pwm, mppt2_status, mppt3_volt, mppt3_amp, mppt3_pwm, mppt3_status))
            
        def set_cam_shutter_encode(self, cam_no, cam_mode, trigger_pin, interval, exposure, gain):
                '''
                

                cam_no                    : Camera id (uint8_t)
                cam_mode                  : Camera mode: 0 = auto, 1 = manual (uint8_t)
                trigger_pin               : Trigger pin, 0-3 for PtGrey FireFly (uint8_t)
                interval                  : Shutter interval, in microseconds (uint16_t)
                exposure                  : Exposure time, in microseconds (uint16_t)
                gain                      : Camera gain (float)

                '''
                msg = MAVLink_set_cam_shutter_message(cam_no, cam_mode, trigger_pin, interval, exposure, gain)
                msg.pack(self)
                return msg
            
        def set_cam_shutter_send(self, cam_no, cam_mode, trigger_pin, interval, exposure, gain):
                '''
                

                cam_no                    : Camera id (uint8_t)
                cam_mode                  : Camera mode: 0 = auto, 1 = manual (uint8_t)
                trigger_pin               : Trigger pin, 0-3 for PtGrey FireFly (uint8_t)
                interval                  : Shutter interval, in microseconds (uint16_t)
                exposure                  : Exposure time, in microseconds (uint16_t)
                gain                      : Camera gain (float)

                '''
                return self.send(self.set_cam_shutter_encode(cam_no, cam_mode, trigger_pin, interval, exposure, gain))
            
        def image_triggered_encode(self, timestamp, seq, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z):
                '''
                

                timestamp                 : Timestamp (uint64_t)
                seq                       : IMU seq (uint32_t)
                roll                      : Roll angle in rad (float)
                pitch                     : Pitch angle in rad (float)
                yaw                       : Yaw angle in rad (float)
                local_z                   : Local frame Z coordinate (height over ground) (float)
                lat                       : GPS X coordinate (float)
                lon                       : GPS Y coordinate (float)
                alt                       : Global frame altitude (float)
                ground_x                  : Ground truth X (float)
                ground_y                  : Ground truth Y (float)
                ground_z                  : Ground truth Z (float)

                '''
                msg = MAVLink_image_triggered_message(timestamp, seq, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z)
                msg.pack(self)
                return msg
            
        def image_triggered_send(self, timestamp, seq, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z):
                '''
                

                timestamp                 : Timestamp (uint64_t)
                seq                       : IMU seq (uint32_t)
                roll                      : Roll angle in rad (float)
                pitch                     : Pitch angle in rad (float)
                yaw                       : Yaw angle in rad (float)
                local_z                   : Local frame Z coordinate (height over ground) (float)
                lat                       : GPS X coordinate (float)
                lon                       : GPS Y coordinate (float)
                alt                       : Global frame altitude (float)
                ground_x                  : Ground truth X (float)
                ground_y                  : Ground truth Y (float)
                ground_z                  : Ground truth Z (float)

                '''
                return self.send(self.image_triggered_encode(timestamp, seq, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z))
            
        def image_trigger_control_encode(self, enable):
                '''
                

                enable                    : 0 to disable, 1 to enable (uint8_t)

                '''
                msg = MAVLink_image_trigger_control_message(enable)
                msg.pack(self)
                return msg
            
        def image_trigger_control_send(self, enable):
                '''
                

                enable                    : 0 to disable, 1 to enable (uint8_t)

                '''
                return self.send(self.image_trigger_control_encode(enable))
            
        def image_available_encode(self, cam_id, cam_no, timestamp, valid_until, img_seq, img_buf_index, width, height, depth, channels, key, exposure, gain, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z):
                '''
                

                cam_id                    : Camera id (uint64_t)
                cam_no                    : Camera # (starts with 0) (uint8_t)
                timestamp                 : Timestamp (uint64_t)
                valid_until               : Until which timestamp this buffer will stay valid (uint64_t)
                img_seq                   : The image sequence number (uint32_t)
                img_buf_index             : Position of the image in the buffer, starts with 0 (uint32_t)
                width                     : Image width (uint16_t)
                height                    : Image height (uint16_t)
                depth                     : Image depth (uint16_t)
                channels                  : Image channels (uint8_t)
                key                       : Shared memory area key (uint32_t)
                exposure                  : Exposure time, in microseconds (uint32_t)
                gain                      : Camera gain (float)
                roll                      : Roll angle in rad (float)
                pitch                     : Pitch angle in rad (float)
                yaw                       : Yaw angle in rad (float)
                local_z                   : Local frame Z coordinate (height over ground) (float)
                lat                       : GPS X coordinate (float)
                lon                       : GPS Y coordinate (float)
                alt                       : Global frame altitude (float)
                ground_x                  : Ground truth X (float)
                ground_y                  : Ground truth Y (float)
                ground_z                  : Ground truth Z (float)

                '''
                msg = MAVLink_image_available_message(cam_id, cam_no, timestamp, valid_until, img_seq, img_buf_index, width, height, depth, channels, key, exposure, gain, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z)
                msg.pack(self)
                return msg
            
        def image_available_send(self, cam_id, cam_no, timestamp, valid_until, img_seq, img_buf_index, width, height, depth, channels, key, exposure, gain, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z):
                '''
                

                cam_id                    : Camera id (uint64_t)
                cam_no                    : Camera # (starts with 0) (uint8_t)
                timestamp                 : Timestamp (uint64_t)
                valid_until               : Until which timestamp this buffer will stay valid (uint64_t)
                img_seq                   : The image sequence number (uint32_t)
                img_buf_index             : Position of the image in the buffer, starts with 0 (uint32_t)
                width                     : Image width (uint16_t)
                height                    : Image height (uint16_t)
                depth                     : Image depth (uint16_t)
                channels                  : Image channels (uint8_t)
                key                       : Shared memory area key (uint32_t)
                exposure                  : Exposure time, in microseconds (uint32_t)
                gain                      : Camera gain (float)
                roll                      : Roll angle in rad (float)
                pitch                     : Pitch angle in rad (float)
                yaw                       : Yaw angle in rad (float)
                local_z                   : Local frame Z coordinate (height over ground) (float)
                lat                       : GPS X coordinate (float)
                lon                       : GPS Y coordinate (float)
                alt                       : Global frame altitude (float)
                ground_x                  : Ground truth X (float)
                ground_y                  : Ground truth Y (float)
                ground_z                  : Ground truth Z (float)

                '''
                return self.send(self.image_available_encode(cam_id, cam_no, timestamp, valid_until, img_seq, img_buf_index, width, height, depth, channels, key, exposure, gain, roll, pitch, yaw, local_z, lat, lon, alt, ground_x, ground_y, ground_z))
            
        def set_position_control_offset_encode(self, target_system, target_component, x, y, z, yaw):
                '''
                Message sent to the MAV to set a new offset from the currently
                controlled position

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                x                         : x position offset (float)
                y                         : y position offset (float)
                z                         : z position offset (float)
                yaw                       : yaw orientation offset in radians, 0 = NORTH (float)

                '''
                msg = MAVLink_set_position_control_offset_message(target_system, target_component, x, y, z, yaw)
                msg.pack(self)
                return msg
            
        def set_position_control_offset_send(self, target_system, target_component, x, y, z, yaw):
                '''
                Message sent to the MAV to set a new offset from the currently
                controlled position

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                x                         : x position offset (float)
                y                         : y position offset (float)
                z                         : z position offset (float)
                yaw                       : yaw orientation offset in radians, 0 = NORTH (float)

                '''
                return self.send(self.set_position_control_offset_encode(target_system, target_component, x, y, z, yaw))
            
        def position_control_setpoint_encode(self, id, x, y, z, yaw):
                '''
                

                id                        : ID of waypoint, 0 for plain position (uint16_t)
                x                         : x position (float)
                y                         : y position (float)
                z                         : z position (float)
                yaw                       : yaw orientation in radians, 0 = NORTH (float)

                '''
                msg = MAVLink_position_control_setpoint_message(id, x, y, z, yaw)
                msg.pack(self)
                return msg
            
        def position_control_setpoint_send(self, id, x, y, z, yaw):
                '''
                

                id                        : ID of waypoint, 0 for plain position (uint16_t)
                x                         : x position (float)
                y                         : y position (float)
                z                         : z position (float)
                yaw                       : yaw orientation in radians, 0 = NORTH (float)

                '''
                return self.send(self.position_control_setpoint_encode(id, x, y, z, yaw))
            
        def marker_encode(self, id, x, y, z, roll, pitch, yaw):
                '''
                

                id                        : ID (uint16_t)
                x                         : x position (float)
                y                         : y position (float)
                z                         : z position (float)
                roll                      : roll orientation (float)
                pitch                     : pitch orientation (float)
                yaw                       : yaw orientation (float)

                '''
                msg = MAVLink_marker_message(id, x, y, z, roll, pitch, yaw)
                msg.pack(self)
                return msg
            
        def marker_send(self, id, x, y, z, roll, pitch, yaw):
                '''
                

                id                        : ID (uint16_t)
                x                         : x position (float)
                y                         : y position (float)
                z                         : z position (float)
                roll                      : roll orientation (float)
                pitch                     : pitch orientation (float)
                yaw                       : yaw orientation (float)

                '''
                return self.send(self.marker_encode(id, x, y, z, roll, pitch, yaw))
            
        def raw_aux_encode(self, adc1, adc2, adc3, adc4, vbat, temp, baro):
                '''
                

                adc1                      : ADC1 (J405 ADC3, LPC2148 AD0.6) (uint16_t)
                adc2                      : ADC2 (J405 ADC5, LPC2148 AD0.2) (uint16_t)
                adc3                      : ADC3 (J405 ADC6, LPC2148 AD0.1) (uint16_t)
                adc4                      : ADC4 (J405 ADC7, LPC2148 AD1.3) (uint16_t)
                vbat                      : Battery voltage (uint16_t)
                temp                      : Temperature (degrees celcius) (int16_t)
                baro                      : Barometric pressure (hecto Pascal) (int32_t)

                '''
                msg = MAVLink_raw_aux_message(adc1, adc2, adc3, adc4, vbat, temp, baro)
                msg.pack(self)
                return msg
            
        def raw_aux_send(self, adc1, adc2, adc3, adc4, vbat, temp, baro):
                '''
                

                adc1                      : ADC1 (J405 ADC3, LPC2148 AD0.6) (uint16_t)
                adc2                      : ADC2 (J405 ADC5, LPC2148 AD0.2) (uint16_t)
                adc3                      : ADC3 (J405 ADC6, LPC2148 AD0.1) (uint16_t)
                adc4                      : ADC4 (J405 ADC7, LPC2148 AD1.3) (uint16_t)
                vbat                      : Battery voltage (uint16_t)
                temp                      : Temperature (degrees celcius) (int16_t)
                baro                      : Barometric pressure (hecto Pascal) (int32_t)

                '''
                return self.send(self.raw_aux_encode(adc1, adc2, adc3, adc4, vbat, temp, baro))
            
        def watchdog_heartbeat_encode(self, watchdog_id, process_count):
                '''
                

                watchdog_id               : Watchdog ID (uint16_t)
                process_count             : Number of processes (uint16_t)

                '''
                msg = MAVLink_watchdog_heartbeat_message(watchdog_id, process_count)
                msg.pack(self)
                return msg
            
        def watchdog_heartbeat_send(self, watchdog_id, process_count):
                '''
                

                watchdog_id               : Watchdog ID (uint16_t)
                process_count             : Number of processes (uint16_t)

                '''
                return self.send(self.watchdog_heartbeat_encode(watchdog_id, process_count))
            
        def watchdog_process_info_encode(self, watchdog_id, process_id, name, arguments, timeout):
                '''
                

                watchdog_id               : Watchdog ID (uint16_t)
                process_id                : Process ID (uint16_t)
                name                      : Process name (char)
                arguments                 : Process arguments (char)
                timeout                   : Timeout (seconds) (int32_t)

                '''
                msg = MAVLink_watchdog_process_info_message(watchdog_id, process_id, name, arguments, timeout)
                msg.pack(self)
                return msg
            
        def watchdog_process_info_send(self, watchdog_id, process_id, name, arguments, timeout):
                '''
                

                watchdog_id               : Watchdog ID (uint16_t)
                process_id                : Process ID (uint16_t)
                name                      : Process name (char)
                arguments                 : Process arguments (char)
                timeout                   : Timeout (seconds) (int32_t)

                '''
                return self.send(self.watchdog_process_info_encode(watchdog_id, process_id, name, arguments, timeout))
            
        def watchdog_process_status_encode(self, watchdog_id, process_id, state, muted, pid, crashes):
                '''
                

                watchdog_id               : Watchdog ID (uint16_t)
                process_id                : Process ID (uint16_t)
                state                     : Is running / finished / suspended / crashed (uint8_t)
                muted                     : Is muted (uint8_t)
                pid                       : PID (int32_t)
                crashes                   : Number of crashes (uint16_t)

                '''
                msg = MAVLink_watchdog_process_status_message(watchdog_id, process_id, state, muted, pid, crashes)
                msg.pack(self)
                return msg
            
        def watchdog_process_status_send(self, watchdog_id, process_id, state, muted, pid, crashes):
                '''
                

                watchdog_id               : Watchdog ID (uint16_t)
                process_id                : Process ID (uint16_t)
                state                     : Is running / finished / suspended / crashed (uint8_t)
                muted                     : Is muted (uint8_t)
                pid                       : PID (int32_t)
                crashes                   : Number of crashes (uint16_t)

                '''
                return self.send(self.watchdog_process_status_encode(watchdog_id, process_id, state, muted, pid, crashes))
            
        def watchdog_command_encode(self, target_system_id, watchdog_id, process_id, command_id):
                '''
                

                target_system_id          : Target system ID (uint8_t)
                watchdog_id               : Watchdog ID (uint16_t)
                process_id                : Process ID (uint16_t)
                command_id                : Command ID (uint8_t)

                '''
                msg = MAVLink_watchdog_command_message(target_system_id, watchdog_id, process_id, command_id)
                msg.pack(self)
                return msg
            
        def watchdog_command_send(self, target_system_id, watchdog_id, process_id, command_id):
                '''
                

                target_system_id          : Target system ID (uint8_t)
                watchdog_id               : Watchdog ID (uint16_t)
                process_id                : Process ID (uint16_t)
                command_id                : Command ID (uint8_t)

                '''
                return self.send(self.watchdog_command_encode(target_system_id, watchdog_id, process_id, command_id))
            
        def pattern_detected_encode(self, type, confidence, file, detected):
                '''
                

                type                      : 0: Pattern, 1: Letter (uint8_t)
                confidence                : Confidence of detection (float)
                file                      : Pattern file name (char)
                detected                  : Accepted as true detection, 0 no, 1 yes (uint8_t)

                '''
                msg = MAVLink_pattern_detected_message(type, confidence, file, detected)
                msg.pack(self)
                return msg
            
        def pattern_detected_send(self, type, confidence, file, detected):
                '''
                

                type                      : 0: Pattern, 1: Letter (uint8_t)
                confidence                : Confidence of detection (float)
                file                      : Pattern file name (char)
                detected                  : Accepted as true detection, 0 no, 1 yes (uint8_t)

                '''
                return self.send(self.pattern_detected_encode(type, confidence, file, detected))
            
        def point_of_interest_encode(self, type, color, coordinate_system, timeout, x, y, z, name):
                '''
                Notifies the operator about a point of interest (POI). This can be
                anything detected by the                 system. This
                generic message is intented to help interfacing to
                generic visualizations and to display
                the POI on a map.

                type                      : 0: Notice, 1: Warning, 2: Critical, 3: Emergency, 4: Debug (uint8_t)
                color                     : 0: blue, 1: yellow, 2: red, 3: orange, 4: green, 5: magenta (uint8_t)
                coordinate_system         : 0: global, 1:local (uint8_t)
                timeout                   : 0: no timeout, >1: timeout in seconds (uint16_t)
                x                         : X Position (float)
                y                         : Y Position (float)
                z                         : Z Position (float)
                name                      : POI name (char)

                '''
                msg = MAVLink_point_of_interest_message(type, color, coordinate_system, timeout, x, y, z, name)
                msg.pack(self)
                return msg
            
        def point_of_interest_send(self, type, color, coordinate_system, timeout, x, y, z, name):
                '''
                Notifies the operator about a point of interest (POI). This can be
                anything detected by the                 system. This
                generic message is intented to help interfacing to
                generic visualizations and to display
                the POI on a map.

                type                      : 0: Notice, 1: Warning, 2: Critical, 3: Emergency, 4: Debug (uint8_t)
                color                     : 0: blue, 1: yellow, 2: red, 3: orange, 4: green, 5: magenta (uint8_t)
                coordinate_system         : 0: global, 1:local (uint8_t)
                timeout                   : 0: no timeout, >1: timeout in seconds (uint16_t)
                x                         : X Position (float)
                y                         : Y Position (float)
                z                         : Z Position (float)
                name                      : POI name (char)

                '''
                return self.send(self.point_of_interest_encode(type, color, coordinate_system, timeout, x, y, z, name))
            
        def point_of_interest_connection_encode(self, type, color, coordinate_system, timeout, xp1, yp1, zp1, xp2, yp2, zp2, name):
                '''
                Notifies the operator about the connection of two point of interests
                (POI). This can be anything detected by the
                system. This generic message is intented to help
                interfacing to generic visualizations and to display
                the POI on a map.

                type                      : 0: Notice, 1: Warning, 2: Critical, 3: Emergency, 4: Debug (uint8_t)
                color                     : 0: blue, 1: yellow, 2: red, 3: orange, 4: green, 5: magenta (uint8_t)
                coordinate_system         : 0: global, 1:local (uint8_t)
                timeout                   : 0: no timeout, >1: timeout in seconds (uint16_t)
                xp1                       : X1 Position (float)
                yp1                       : Y1 Position (float)
                zp1                       : Z1 Position (float)
                xp2                       : X2 Position (float)
                yp2                       : Y2 Position (float)
                zp2                       : Z2 Position (float)
                name                      : POI connection name (char)

                '''
                msg = MAVLink_point_of_interest_connection_message(type, color, coordinate_system, timeout, xp1, yp1, zp1, xp2, yp2, zp2, name)
                msg.pack(self)
                return msg
            
        def point_of_interest_connection_send(self, type, color, coordinate_system, timeout, xp1, yp1, zp1, xp2, yp2, zp2, name):
                '''
                Notifies the operator about the connection of two point of interests
                (POI). This can be anything detected by the
                system. This generic message is intented to help
                interfacing to generic visualizations and to display
                the POI on a map.

                type                      : 0: Notice, 1: Warning, 2: Critical, 3: Emergency, 4: Debug (uint8_t)
                color                     : 0: blue, 1: yellow, 2: red, 3: orange, 4: green, 5: magenta (uint8_t)
                coordinate_system         : 0: global, 1:local (uint8_t)
                timeout                   : 0: no timeout, >1: timeout in seconds (uint16_t)
                xp1                       : X1 Position (float)
                yp1                       : Y1 Position (float)
                zp1                       : Z1 Position (float)
                xp2                       : X2 Position (float)
                yp2                       : Y2 Position (float)
                zp2                       : Z2 Position (float)
                name                      : POI connection name (char)

                '''
                return self.send(self.point_of_interest_connection_encode(type, color, coordinate_system, timeout, xp1, yp1, zp1, xp2, yp2, zp2, name))
            
        def data_transmission_handshake_encode(self, type, size, width, height, packets, payload, jpg_quality):
                '''
                

                type                      : type of requested/acknowledged data (as defined in ENUM DATA_TYPES in mavlink/include/mavlink_types.h) (uint8_t)
                size                      : total data size in bytes (set on ACK only) (uint32_t)
                width                     : Width of a matrix or image (uint16_t)
                height                    : Height of a matrix or image (uint16_t)
                packets                   : number of packets beeing sent (set on ACK only) (uint8_t)
                payload                   : payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only) (uint8_t)
                jpg_quality               : JPEG quality out of [1,100] (uint8_t)

                '''
                msg = MAVLink_data_transmission_handshake_message(type, size, width, height, packets, payload, jpg_quality)
                msg.pack(self)
                return msg
            
        def data_transmission_handshake_send(self, type, size, width, height, packets, payload, jpg_quality):
                '''
                

                type                      : type of requested/acknowledged data (as defined in ENUM DATA_TYPES in mavlink/include/mavlink_types.h) (uint8_t)
                size                      : total data size in bytes (set on ACK only) (uint32_t)
                width                     : Width of a matrix or image (uint16_t)
                height                    : Height of a matrix or image (uint16_t)
                packets                   : number of packets beeing sent (set on ACK only) (uint8_t)
                payload                   : payload size per packet (normally 253 byte, see DATA field size in message ENCAPSULATED_DATA) (set on ACK only) (uint8_t)
                jpg_quality               : JPEG quality out of [1,100] (uint8_t)

                '''
                return self.send(self.data_transmission_handshake_encode(type, size, width, height, packets, payload, jpg_quality))
            
        def encapsulated_data_encode(self, seqnr, data):
                '''
                

                seqnr                     : sequence number (starting with 0 on every transmission) (uint16_t)
                data                      : image data bytes (uint8_t)

                '''
                msg = MAVLink_encapsulated_data_message(seqnr, data)
                msg.pack(self)
                return msg
            
        def encapsulated_data_send(self, seqnr, data):
                '''
                

                seqnr                     : sequence number (starting with 0 on every transmission) (uint16_t)
                data                      : image data bytes (uint8_t)

                '''
                return self.send(self.encapsulated_data_encode(seqnr, data))
            
        def brief_feature_encode(self, x, y, z, orientation_assignment, size, orientation, descriptor, response):
                '''
                

                x                         : x position in m (float)
                y                         : y position in m (float)
                z                         : z position in m (float)
                orientation_assignment        : Orientation assignment 0: false, 1:true (uint8_t)
                size                      : Size in pixels (uint16_t)
                orientation               : Orientation (uint16_t)
                descriptor                : Descriptor (uint8_t)
                response                  : Harris operator response at this location (float)

                '''
                msg = MAVLink_brief_feature_message(x, y, z, orientation_assignment, size, orientation, descriptor, response)
                msg.pack(self)
                return msg
            
        def brief_feature_send(self, x, y, z, orientation_assignment, size, orientation, descriptor, response):
                '''
                

                x                         : x position in m (float)
                y                         : y position in m (float)
                z                         : z position in m (float)
                orientation_assignment        : Orientation assignment 0: false, 1:true (uint8_t)
                size                      : Size in pixels (uint16_t)
                orientation               : Orientation (uint16_t)
                descriptor                : Descriptor (uint8_t)
                response                  : Harris operator response at this location (float)

                '''
                return self.send(self.brief_feature_encode(x, y, z, orientation_assignment, size, orientation, descriptor, response))
            
        def attitude_control_encode(self, target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual):
                '''
                

                target                    : The system to be controlled (uint8_t)
                roll                      : roll (float)
                pitch                     : pitch (float)
                yaw                       : yaw (float)
                thrust                    : thrust (float)
                roll_manual               : roll control enabled auto:0, manual:1 (uint8_t)
                pitch_manual              : pitch auto:0, manual:1 (uint8_t)
                yaw_manual                : yaw auto:0, manual:1 (uint8_t)
                thrust_manual             : thrust auto:0, manual:1 (uint8_t)

                '''
                msg = MAVLink_attitude_control_message(target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual)
                msg.pack(self)
                return msg
            
        def attitude_control_send(self, target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual):
                '''
                

                target                    : The system to be controlled (uint8_t)
                roll                      : roll (float)
                pitch                     : pitch (float)
                yaw                       : yaw (float)
                thrust                    : thrust (float)
                roll_manual               : roll control enabled auto:0, manual:1 (uint8_t)
                pitch_manual              : pitch auto:0, manual:1 (uint8_t)
                yaw_manual                : yaw auto:0, manual:1 (uint8_t)
                thrust_manual             : thrust auto:0, manual:1 (uint8_t)

                '''
                return self.send(self.attitude_control_encode(target, roll, pitch, yaw, thrust, roll_manual, pitch_manual, yaw_manual, thrust_manual))
            
